<html>
    <head>
        <link rel="stylesheet" href="../tufte.css"/>
        <meta charset="UTF-8"/>
        <title>Why have functors when we have fold?</title>
    </head>
    <body>
        <h1>Why have functors when we have fold?</h1>
        <p>A paper from 1999 by Graham Hutton, titled <a href="http://www.cs.nott.ac.uk/~pszgmh/fold.pdf">A tutorial on the universality and expressiveness of fold</a>, shows how the recursive fold function can be used for many recursive patterns, including the map. Map of course, in its general definition is a very useful and common pattern in functional programming. In Haskell, the generalization of a map on lists is fmap, implemented in the Functor type class.</p><p><code> Functor f =&gt; fmap :: a -&gt; b -&gt; f a -&gt; f b </code></p><p>Functors are indeed a very useful pattern, they help in specifying a way for special containers of things to be operated on with normal functions. For instance when we want to add 1 to numbers in a list, we don’t need a new add function; <code> fmap (+ 1) [2 2 3] </code></p><p>But a map on lists can be defined in terms of fold like so..</p><p><code><p>fold :: a -&gt; b -&gt; b -&gt; [a]<br/>fold = ..</p><p>map f = fold (\(x,xs) -&gt; f x : xs) []</p></code></p><p>From fold we can also implement filter, reverse, and length (Hutton). Would fold have been a more general and more universal abstraction for functional programming? Should we be defining data types in terms of an abstract folding class instead of functors? Such a type class that defines a fold would have a default implementation of map too. That is, if the above definition of map in terms of fold can be generalized to other data types beyond just the list.</p><p>Consider the case of enumerating the values a custom-defined recursive tree-like structure.</p><p><code>data Tree a = Nil | Node a (Tree a) (Tree a)</code></p><p>Enumeration is an accumulative operation so it can’t be defined in terms of map; a functor is of no use here. But <code>enumerate :: Tree a -&gt; Tree (a, Int)</code> can be defined in terms of fold. If this were written in Racket, or Javascipt or the likes, this would already be quite a burden to define in a functional way because  the standard library definitions of fold expect to operate on lists and lists only. There is no broader concept of a foldable data type.</p><p>Haskell has a more abstract type definition: <code>fold :: (Foldable t, Monoid m) =&gt; t m -&gt; m</code><br/>fold is basically taking a Foldable type (a type that implements fold) which contains a type which is a Monoid. Monoid is the general pattern of data that concatenates associatively - for lists it would be the concatenate (:). Fold reduces to a single element of the monoid.</p><p>Interestingly in the case of implementing map in terms of fold for lists above, the list is both the Monoid (f x : xs) and the Foldable, as fold is operating from the empty list.</p><p>Upon some brief inspection into generalized folds, I found the <a href="https://en.wikipedia.org/wiki/Catamorphism">Catamorphism</a>.</p>
    </body>
</html>