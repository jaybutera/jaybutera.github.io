<html>
    <head>
        <!--<link rel="stylesheet" href="../tufte.css"/>-->
        <link rel="stylesheet" href="../styles.css"/>
        <meta charset="UTF-8"/>
        <title>Cheap Proofs of Function Evaluation</title>
    </head>
    <body>
        <div id="article-body">
            <h1>Cheap Proofs of Function Evaluation</h1>
            <p>Suppose you have a really complicated function that takes alot of processing<br/>power, or storage, to compute. You can’t run it on your computer so you<br/>need to pay a provider to run it for you. Suppose this is a well known function<br/>and there are providers who will run your inputs and give you the outputs for a<br/>price.</p><p>How do you know that the result they give you, y, is the result of running your<br/>input, z, on this well known function f; f(z)=y?</p><p>The provider could arithmetize the input and the execution of the circuit and<br/>provide you with a polynomial commitment proof (Plonk) that they have knowledge<br/>of said circuit. And then provide a proof that f(z)=y.</p><p>But since the function f is really complex, so is the proof generation and it<br/>becomes very costly (think at least double the cost of just running the<br/>function) to prove every evaluation on different inputs.</p><p>If you have a way to verify that a commitment is indeed a commitment to f, then<br/>you could use the elliptic curve pairing to check that f(z)=y as is done in<br/>KZG.</p><p>In a snark, both the prover and verifier have knowledge of the circuit<br/>(although only the prover knows the witness). But in this scenario the verifier<br/>won’t have knowledge of the circuit because it is very large and complex.<br/>Instead the verifier just needs to be reasonably sure that the commitment to f<br/>indeed reflects f.</p><p>Suppose there is an MPC computation to construct f in a verifiable way<br/>(although verification will require downloading f and checking the construction<br/>proofs). This computation will require staking of crypto tokens in a challenge<br/>period so that actors involved in the construction are incentivized to report<br/>eachother for false proofs of construction.</p><p>Unless all actors collude to not report eachother (where any one actor could<br/>otherwise get the entire stake of all the malicious colluders), we can be<br/>reasonably sure the produced function f and its commitment are constructed correctly.</p><p>Consider this MPC construction of f and commitment to f to be like a PKI public<br/>key made a by a trusted friend. Once you know it, they can “encrypt” messages<br/>using it, or in this case, evaluate results f(z)=y which you can verify using<br/>KZG with the MPC commitment to f.</p><p>This may find many uses in distributed scientific computing. Where a<br/>distributed group (or individual) run a simulation, or perhaps train a very large AI in a<br/>distributed and verifiable fashion (using zk-snarks on backpropagation for<br/>example). Then from the result of the simulation, users/customers can make<br/>queries which will be evaluated on the model and results returned along with a<br/>cheap proof.</p>
        </div>
    </body>
</html>